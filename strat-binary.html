
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Inference about binary populations from stratified samples &#8212; An Idiosyncratic Subset of Statistics</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">An Idiosyncratic Subset of Statistics</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    Notes on Applied Statistics
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Index of Lecture Notes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="index-app-stats.html">
   An Idiosyncratic Sample of Applied Statistics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="240-spring-2023/index.html">
   Nonparametric Statistics
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Syllabus Statistics 240, spring 2023
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="240-spring-2023/syllabus.html">
   Syllabus for Statistics 240: Nonparametric and Robust Statistics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="240-spring-2023/assignments.html">
   Assignments
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="240-spring-2023/reading.html">
   Reading assignments and collected reading list for nonparametric statistics
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Assignments for Stat 240, spring 2023
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="240-spring-2023/Hw/ps01-background.html">
   1. Problem set 1: Mathematical Preliminaries
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="240-spring-2023/Hw/ps02-binary-experiments.html">
   2. Problem set: binary experiments with binary outcomes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="240-spring-2023/Hw/cp01-tests.html">
   3. Coding project 1
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="240-spring-2023/Hw/cp02-function.html">
   4. Coding project 2
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/pbstark/StatNotes/main?urlpath=tree/strat-binary.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/pbstark/StatNotes"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/pbstark/StatNotes/issues/new?title=Issue%20on%20page%20%2Fstrat-binary.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/strat-binary.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-problem">
   The problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#wright-s-method-sum-of-sidak-intervals">
   Wright’s Method: Sum of Šidák Intervals
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-wendell-schmee-test">
   The Wendell-Schmee Test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constructive-maximization">
   Constructive maximization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#changing-the-direction-of-the-test">
   Changing the direction of the test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sampling-with-replacement">
   Sampling with replacement
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#open-questions">
   Open questions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#comparison-with-wendell-schmee-1996-p-values-and-upper-confidence-bounds">
   Comparison with Wendell &amp; Schmee (1996)
   <span class="math notranslate nohighlight">
    \(P\)
   </span>
   -values and upper confidence bounds
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#reproduce-tables-from-wendell-schmee">
     Reproduce tables from Wendell &amp; Schmee
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#when-is-the-new-method-sharper-than-wendell-schmee">
   When is the new method sharper than Wendell &amp; Schmee?
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Inference about binary populations from stratified samples</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-problem">
   The problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#wright-s-method-sum-of-sidak-intervals">
   Wright’s Method: Sum of Šidák Intervals
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-wendell-schmee-test">
   The Wendell-Schmee Test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constructive-maximization">
   Constructive maximization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#changing-the-direction-of-the-test">
   Changing the direction of the test
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sampling-with-replacement">
   Sampling with replacement
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#open-questions">
   Open questions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#comparison-with-wendell-schmee-1996-p-values-and-upper-confidence-bounds">
   Comparison with Wendell &amp; Schmee (1996)
   <span class="math notranslate nohighlight">
    \(P\)
   </span>
   -values and upper confidence bounds
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#reproduce-tables-from-wendell-schmee">
     Reproduce tables from Wendell &amp; Schmee
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#when-is-the-new-method-sharper-than-wendell-schmee">
   When is the new method sharper than Wendell &amp; Schmee?
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="inference-about-binary-populations-from-stratified-samples">
<h1>Inference about binary populations from stratified samples<a class="headerlink" href="#inference-about-binary-populations-from-stratified-samples" title="Permalink to this headline">#</a></h1>
<p>Many (if not most) books on survey sampling recommend stratified sampling, but do not address how to construct exact or conservative confidence sets from stratified samples.
Instead, they recommend approximate confidence intervals based on the normal approximation.
As we have seen, confidence intervals based on the normal approximation can have terrible coverage
probability in practice–much lower than they claim to have–even for large sample sizes, depending on
the population distribution.</p>
<p>This chapter constructs conservative and exact tests and confidence bounds for the population total (or mean) of a binary population from a stratified random sample, where the sample from each stratum is a simple random sample.</p>
<p>Three approaches are discussed:</p>
<ol class="simple">
<li><p>Wright’s method, which finds simultaneous confidence bounds for the number of 1s in each stratum using Šidák’s method, then adds the bounds.</p></li>
<li><p>Wendell &amp; Schmee’s method (1996, <a class="reference external" href="https://www.tandfonline.com/doi/abs/10.1080/01621459.1996.10476950">https://www.tandfonline.com/doi/abs/10.1080/01621459.1996.10476950</a>), which is based on inverting tests of hypotheses that specify the number of 1s in each stratum. The test statistic is <span class="math notranslate nohighlight">\(\hat{p}\)</span>, the unbiased estimate of the overall population proportion. The <span class="math notranslate nohighlight">\(P\)</span>-value for the hypothesis that the total number of 1s in the population is <span class="math notranslate nohighlight">\(g\)</span> is the largest <span class="math notranslate nohighlight">\(P\)</span>-value across all ways of allocating <span class="math notranslate nohighlight">\(g\)</span> ones across the strata. Finding the largest <span class="math notranslate nohighlight">\(P\)</span>-value involves examining a combinatorial number of allocations, so the method becomes infeasible as the number of strata grows (beyond approximately 3).</p></li>
<li><p>A new method based on inverting tests of hypotheses that specify the number of 1s in each stratum, where such hypotheses are viewed as an <em>intersection hypothesis</em>: the intersection of separate hypotheses about the number of 1s in each stratum by itself.  The test statistic is Fisher’s combining function (or any other <span class="math notranslate nohighlight">\(P\)</span>-value combining function) applied to the <span class="math notranslate nohighlight">\(P\)</span>-values from the individual stratumwise tests. The <span class="math notranslate nohighlight">\(P\)</span>-value for the hypothesis that the total number of 1s in the population is <span class="math notranslate nohighlight">\(g\)</span> is the largest <span class="math notranslate nohighlight">\(P\)</span>-value across all ways of allocating <span class="math notranslate nohighlight">\(g\)</span> ones across the strata. In contrast to the Wendell-Schmee method, that maximization can be performed constructively rather than requiring a combinatorial search. That makes the method applicable even when the number of strata is large.</p></li>
</ol>
<p>This chapter derives and illustrates specific methods for a particular problem, but along the way it illustrates a number of
broadly useful things:</p>
<ol class="simple">
<li><p>Simultaneous confidence intervals based on independent observations via Šidák’s inequality.</p></li>
<li><p>Finding a confidence set for a multidimensional parameter by finding simultaneously valid confidence sets for the individual components of the parameter.</p></li>
<li><p>Finding a confidence set for a function of a (multidimensional) parameter by looking at the range of the function over a confidence set for the (multidimensional) parameter.</p></li>
<li><p>Maximizing <span class="math notranslate nohighlight">\(P\)</span>-values over nuisance parameters, a general approach that can be applied widely to test composite hypotheses, including situations with nuisance parameters.</p></li>
<li><p>Representing composite nulls as a union of intersection nulls.</p></li>
<li><p>Combining independent <span class="math notranslate nohighlight">\(P\)</span> values using Fisher’s combining function (see also [combining tests](./</p></li>
<li><p>Different test statistics that produce valid tests in a given problem can have vastly different statistical performance (power) and computational performance (speed).</p></li>
<li><p>Some combinatorial problems can be solved extremely quicly by greedy algorithms.</p></li>
</ol>
<p>Maximizing the <span class="math notranslate nohighlight">\(P\)</span>-value over all allocations of <span class="math notranslate nohighlight">\(G\)</span> ones across <span class="math notranslate nohighlight">\(S\)</span> strata
is combinatorially complex: Feller’s “bars and stars” argument shows that there are <span class="math notranslate nohighlight">\(\binom{G+S-1}{S-1}\)</span> ways to allocate <span class="math notranslate nohighlight">\(G\)</span> indistinguishable objects among <span class="math notranslate nohighlight">\(S\)</span> strata.
(Some of those can be ruled out, for instance if <span class="math notranslate nohighlight">\(G\)</span> exceeds the size of any stratum.)
For <span class="math notranslate nohighlight">\(S=10\)</span> strata of size <span class="math notranslate nohighlight">\(N_s = 400\)</span> and <span class="math notranslate nohighlight">\(G = 300\)</span>,
there are roughly 6.3e+16 allocations: impractical by any standard.</p>
<p>This chapter replicates Wendell &amp; Schmee’s method in python
and introduces a different conservative strategy for stratified inference,
also based on maximizing the <span class="math notranslate nohighlight">\(P\)</span>-value over the nuisance parameters.</p>
<p>The test statistic Wendell &amp; Schmee use is sensible, but only one of infinitely many.
A new method developed here uses a different test statistic: a <span class="math notranslate nohighlight">\(P\)</span>-value combining function (e.g., Fisher’s combining function) applied
to the tail probabilities of individual hypergeometric counts for the separate strata.
A naive approach to maximizing this <span class="math notranslate nohighlight">\(P\)</span>-value over the nuisance parameters
would also involve a search over a combinatorial number of possible allocations.
However:</p>
<ol class="simple">
<li><p>No combinatorial search is necessary: an allocation that yields the largest
<span class="math notranslate nohighlight">\(P\)</span>-values and corresponding confidence bounds can be constructed by a simple
algorithm in order <span class="math notranslate nohighlight">\(N \log N\)</span> operations, where <span class="math notranslate nohighlight">\(N\)</span> is the number of items in the population.
Runtime can be reduced further to <span class="math notranslate nohighlight">\(O( N \log S )\)</span>.
The number of strata has little effect on the complexity of the calculation.</p></li>
<li><p>The resulting tests and confidence intervals are in some cases sharper than those of
Wendell and Schmee, in particular when the strata are heterogeneous–which is often the justification for drawing a stratified sample in the first place.</p></li>
</ol>
<p>The code below implements Wright’s method; the brute-force approach (enumerate all ways of allocating a given number of ones across the strata, find the maximum <span class="math notranslate nohighlight">\(P\)</span>-value across those allocations); the new, more efficient approach, which exploits special structure of the problem; and the Wendell &amp; Schmee approach.</p>
<p>It replicates a number of calculations in the Wendell &amp; Schmee paper.
Several algorithms for finding confidence intervals are implemented, including a line
search, a bisection-like method that takes advantage of the fact that the
possible values are integers, and a fast constructive algorithm for the new method.</p>
<section id="the-problem">
<h2>The problem<a class="headerlink" href="#the-problem" title="Permalink to this headline">#</a></h2>
<p>A population of <span class="math notranslate nohighlight">\(N\)</span> items of which <span class="math notranslate nohighlight">\(G\)</span> are labeled “1” and <span class="math notranslate nohighlight">\(N-G\)</span> are labeled “0”
is allocationed into <span class="math notranslate nohighlight">\(S\)</span> strata.
Stratum <span class="math notranslate nohighlight">\(s\)</span> contains <span class="math notranslate nohighlight">\(N_s\)</span> items, of which <span class="math notranslate nohighlight">\(G_s\)</span> are labeled “1.”
Thus <span class="math notranslate nohighlight">\(N = \sum_{s=1}^S N_s\)</span> and <span class="math notranslate nohighlight">\(G := \sum_{s=1}^S G_s\)</span>.
We draw a simple random sample of size <span class="math notranslate nohighlight">\(n_s\)</span> from stratum <span class="math notranslate nohighlight">\(s\)</span>, independently across strata.
(I.e., from stratum <span class="math notranslate nohighlight">\(s\)</span> we draw a sample of size <span class="math notranslate nohighlight">\(n_s\)</span> in such a way
that every subset of <span class="math notranslate nohighlight">\(n_s\)</span> distinct items of the <span class="math notranslate nohighlight">\(N_s\)</span> items is equally likely;
and the <span class="math notranslate nohighlight">\(S\)</span> samples are drawn independently.)</p>
<p>Let <span class="math notranslate nohighlight">\(Y_s\)</span> denote the number of items labeled “1” in the sample from stratum <span class="math notranslate nohighlight">\(s\)</span>.
The variables <span class="math notranslate nohighlight">\(\{Y_s \}_{s=1}^S\)</span> are independent.
The observed value of <span class="math notranslate nohighlight">\(Y_s\)</span> is <span class="math notranslate nohighlight">\(y_s\)</span>.</p>
<p>We seek hypothesis tests and confidence bounds for <span class="math notranslate nohighlight">\(G\)</span>.
We first consider one-sided tests of the hypothesis <span class="math notranslate nohighlight">\(G = g\)</span> against the
alternative <span class="math notranslate nohighlight">\(G &gt; g\)</span>, and
corresponding lower confidence bounds for <span class="math notranslate nohighlight">\(G\)</span>;
reversing the roles of “0” and “1” gives upper confidence
bounds, <em>mutatis mutandis</em>.</p>
<p>The general strategy for testing the hypothesis <span class="math notranslate nohighlight">\(G=g\)</span> is to
find the largest <span class="math notranslate nohighlight">\(P\)</span>-value among all ways of allocating <span class="math notranslate nohighlight">\(g\)</span>
items labeled “1” among the <span class="math notranslate nohighlight">\(S\)</span> strata
(honoring the stratum sizes <span class="math notranslate nohighlight">\(\{N_s\}\)</span>).
That is a <span class="math notranslate nohighlight">\(P\)</span>-value for the composite hypothesis <span class="math notranslate nohighlight">\(G=g\)</span>.
The maximum can be found by examining all such allocations and
calculating the <span class="math notranslate nohighlight">\(P\)</span>-value for each.</p>
</section>
<section id="wright-s-method-sum-of-sidak-intervals">
<h2>Wright’s Method: Sum of Šidák Intervals<a class="headerlink" href="#wright-s-method-sum-of-sidak-intervals" title="Permalink to this headline">#</a></h2>
<p>One easy way to get a lower confidence bound for the sum is to take the sum of
simultaneous lower confidence bounds for each stratum.
Because the samples from different strata are independent, Šidák’s adjustment works.
Wright (1991) suggests this approach.</p>
<p>A confidence bound for <span class="math notranslate nohighlight">\(G_s\)</span> can be constructed from <span class="math notranslate nohighlight">\(Y\)</span> by inverting hypergeometric tests.</p>
<p>To have joint confidence level <span class="math notranslate nohighlight">\(1-\alpha\)</span>, make each confidence interval at <span class="math notranslate nohighlight">\((1-\alpha)^{1/S}\)</span>.</p>
<p>This is an example of a much more general approach: make a joint <span class="math notranslate nohighlight">\(1-\alpha\)</span> confidence set for all the parameters <span class="math notranslate nohighlight">\(\{G_j\}_{j=1}^S\)</span>, then find a lower bound on a functional of interest (here, their sum) over the joint set. Whenever the joint confidence set covers the parameter, the lower bound does not exceed the true value of the functional of the parameter.</p>
</section>
<section id="the-wendell-schmee-test">
<h2>The Wendell-Schmee Test<a class="headerlink" href="#the-wendell-schmee-test" title="Permalink to this headline">#</a></h2>
<p>The test statistic for the Wendell-Schmee test is the unbiased estimate
of the population proportion, <span class="math notranslate nohighlight">\(G/N\)</span>:</p>
<div class="math notranslate nohighlight">
\[
  \hat{p} := \frac{1}{N} \sum_{s=1}^S N_s y_s/n_s.
\]</div>
<p>The <span class="math notranslate nohighlight">\(P\)</span>-value of the hypothesis <span class="math notranslate nohighlight">\(G_s=g_s\)</span>, <span class="math notranslate nohighlight">\(s=1, \ldots, S\)</span>,
is the “lower tail probability” of <span class="math notranslate nohighlight">\(\hat{p}\)</span> computed on the assumption that <span class="math notranslate nohighlight">\(G_s=g_s\)</span>, <span class="math notranslate nohighlight">\(s=1, \ldots, S\)</span>.</p>
<p>Wendell and Schmee consider maximizing this lower tail probability over all allocations
of <span class="math notranslate nohighlight">\(g\)</span> ones across strata, either by exhaustive search, or by numerical optimization
using a descent method from some number of random starting points.
(They show graphically that the tail probability is not convex in the original
parametrization.)</p>
</section>
<section id="constructive-maximization">
<h2>Constructive maximization<a class="headerlink" href="#constructive-maximization" title="Permalink to this headline">#</a></h2>
<p>For some test statistics, there is a much more efficient approach, developed here.</p>
<p>Define
$<span class="math notranslate nohighlight">\(
   p_s(g_s) := \mathbb{P} \{ Y_s \ge y_s || G_s = g_s \} =
   \sum_{y = y_s}^{g_s} \frac{\binom{g_s}{y} \binom{N_s-g_s}{n_s - y}}{\binom{N_s}{n_s}},
\)</span><span class="math notranslate nohighlight">\(
where \)</span>\binom{a}{b} := 0<span class="math notranslate nohighlight">\( if \)</span>a \le 0<span class="math notranslate nohighlight">\( or \)</span>b &gt; a<span class="math notranslate nohighlight">\(.
(The double vertical bars denote &quot;computed on the assumption that.&quot;)
This upper tail probability is a \)</span>P<span class="math notranslate nohighlight">\(-value for the most powerful family of tests of the
hypothesis \)</span>G_s = g_s<span class="math notranslate nohighlight">\( against the alternative \)</span>G_s &gt; g_s$.</p>
<p><strong>Aside:</strong> Suppose <span class="math notranslate nohighlight">\(U \sim U[0, 1]\)</span>.
Then <span class="math notranslate nohighlight">\(-2\ln U\)</span> has an exponential distribution, which is also the chi-square distribution with 2 degrees of
freedom.
The sum of independent random variables with chi-square distributions has a chi-square distribution
with degrees of freedom equal to the sum of the degrees of freedom of the variables in the sum.
Hence, if <span class="math notranslate nohighlight">\(\{U_j\}_{j=1}^S\)</span> are IID uniform, then <span class="math notranslate nohighlight">\(-2 \sum_j \ln U_j\)</span> has a chi-square distribution with <span class="math notranslate nohighlight">\(2S\)</span>
degrees of freedom.</p>
<p>A test of the conjunction hypothesis <span class="math notranslate nohighlight">\(G_s = g_s\)</span>, <span class="math notranslate nohighlight">\(s=1, \ldots, S\)</span> can be constructed
using <em>Fisher’s combining function</em>:
if all <span class="math notranslate nohighlight">\(S\)</span> hypotheses are true, the distribution of
$<span class="math notranslate nohighlight">\(
  X^2(\vec{g}) := -2 \sum_{s=1}^S \log p_s(g_s)
\)</span><span class="math notranslate nohighlight">\(
is dominated by the chi-square distribution with \)</span>2S<span class="math notranslate nohighlight">\( degrees of freedom.
Let \)</span>\chi_d(z)<span class="math notranslate nohighlight">\( denote the chance that a random variable with the chi-square 
distribution with \)</span>d<span class="math notranslate nohighlight">\( degrees of freedom is greater than or equal to \)</span>z<span class="math notranslate nohighlight">\(.
Then a conservative \)</span>P<span class="math notranslate nohighlight">\(-value for the allocation \)</span>\vec{g}<span class="math notranslate nohighlight">\( is
\)</span><span class="math notranslate nohighlight">\(
   P(\vec{g}) = \chi_{2S}(X^2(\vec{g})).
\)</span><span class="math notranslate nohighlight">\(
The allocation \)</span>\vec{g}<span class="math notranslate nohighlight">\( of \)</span>g<span class="math notranslate nohighlight">\( ones across strata that maximizes the \)</span>P<span class="math notranslate nohighlight">\(-value
is the allocation that minimizes \)</span>X^2(\vec{g})<span class="math notranslate nohighlight">\( and satisfies \)</span>\sum_s g_s = g<span class="math notranslate nohighlight">\(.
Equivalently, it is the allocation that maximizes \)</span>\sum_{s=1}^S \log p_s(g_s)$.</p>
<p>Let
$<span class="math notranslate nohighlight">\(
   a_s(j) := \left \{ 
                 \begin{array}{ll} 
          \log p_s(y_s), &amp; j = y_s \\
          \log \left (p_s(j)/p_s(j-1) \right ), &amp; j = y_s+1, \ldots N_s-(n_s-y_s).
                 \end{array}
                 \right .
\)</span>$</p>
<p>Then <span class="math notranslate nohighlight">\(\log p_s(g_s) = \sum_{j=y_s}^{g_s} a_s(j)\)</span> if
<span class="math notranslate nohighlight">\(y_s \le g_s \le N-(n_s-y_s)\)</span>, and
<span class="math notranslate nohighlight">\(\log p_s(g_s) = -\infty\)</span> otherwise.
Moreover,
$<span class="math notranslate nohighlight">\(
  X^2(\vec{g}) =  -2\sum_{s=1}^S a_s(y_s) -2\sum_{s=1}^S \sum_{j=y_s+1}^{g_s} a_s(j)
\)</span><span class="math notranslate nohighlight">\(
provided \)</span>y_s \le g_s \le N-(n_s-y_s)<span class="math notranslate nohighlight">\(, \)</span>s=1, \ldots, S$; otherwise, it is infinite.</p>
<p>An allocation of <span class="math notranslate nohighlight">\(g\)</span> ones across strata is inconsistent with the data unless
<span class="math notranslate nohighlight">\(g_s \ge y_s\)</span>, <span class="math notranslate nohighlight">\(s=1, \ldots, S\)</span>.
Thus, in considering how to allocate <span class="math notranslate nohighlight">\(g\)</span> ones to maximize the <span class="math notranslate nohighlight">\(P\)</span>-value,
the first sum above, accounting for <span class="math notranslate nohighlight">\(\sum_s y_s\)</span> ones, is “mandatory,” or the <span class="math notranslate nohighlight">\(P\)</span>-value will be zero.
The question is how to allocate the remaining <span class="math notranslate nohighlight">\(g - \sum_s y_s\)</span> ones to maximize
the <span class="math notranslate nohighlight">\(P\)</span>-value (equivalently, to minimize <span class="math notranslate nohighlight">\(X^2(\vec{g})\)</span>).</p>
<p>Let <span class="math notranslate nohighlight">\(b_k\)</span> denote the <span class="math notranslate nohighlight">\(k\)</span>th largest element of the set</p>
<div class="math notranslate nohighlight">
\[
   \{a_s(j): j=y_s+1, \ldots, N_s-(n_s-y_s), \;\; s=1, \ldots, S \},
\]</div>
<p>with ties broken arbitrarily.
Define <span class="math notranslate nohighlight">\(\tilde{g}_y := g - \sum_{s=1}^S y_s\)</span>.</p>
<p><strong>Proposition.</strong> For every <span class="math notranslate nohighlight">\(\vec{g}\)</span> with <span class="math notranslate nohighlight">\(\sum_s g_s = g\)</span>,
$<span class="math notranslate nohighlight">\(
X^2(\vec{g}) \ge X_*^2(g) := \left \{ \begin{array}{ll}
    -2 \left ( \sum_{s=1}^S a_s(y_s) + \sum_{k=1}^{\tilde{g}_y} b_k 
                \right ), &amp; \sum_s y_s \le g \le N - \sum_s (n_s-y_s) \\
    \infty, &amp; \mbox{ otherwise. }
    \end{array}
    \right . 
\)</span>$</p>
<p><strong>Proof.</strong> Any <span class="math notranslate nohighlight">\(\vec{g}\)</span> for which <span class="math notranslate nohighlight">\(X^2(\vec{g})\)</span> is finite includes the first sum
and a sum of <span class="math notranslate nohighlight">\(\tilde{g}_y\)</span> elements of <span class="math notranslate nohighlight">\(\{b_k\}\)</span>; the latter is at most the sum of the
<span class="math notranslate nohighlight">\(\tilde{g}_y\)</span> largest elements of <span class="math notranslate nohighlight">\(\{b_k\}\)</span>. <span class="math notranslate nohighlight">\(\Box\)</span></p>
<p>Moreover, the bound is sharp, because <span class="math notranslate nohighlight">\(a_s(j)\)</span> decrease monotonically with <span class="math notranslate nohighlight">\(j\)</span> for
<span class="math notranslate nohighlight">\(j = y_s+1, \ldots, N_s-(n_s-y_s)\)</span>.
Thus, if <span class="math notranslate nohighlight">\(a_s(i)\)</span> is a term in the second sum for some <span class="math notranslate nohighlight">\(i &gt; y_s+1\)</span>, so
is every <span class="math notranslate nohighlight">\(a_s(j)\)</span>, <span class="math notranslate nohighlight">\(y_s \le j \le i-1\)</span>: the second sum indeed corresponds
to a particular allocation
<span class="math notranslate nohighlight">\(\vec{g}\)</span> of <span class="math notranslate nohighlight">\(g\)</span> ones across the <span class="math notranslate nohighlight">\(S\)</span> strata, with <span class="math notranslate nohighlight">\(y_s \le g_s \le N_s-(n_s-y_s)\)</span>.
Among all allocations of <span class="math notranslate nohighlight">\(g\)</span> items labeled “1,” this one minimizes has the smallest tail
probability, because it corresponds to the exponentiation of the smallest sum of logs
(the largest negative sum of logs). <span class="math notranslate nohighlight">\(\Box\)</span></p>
<p><strong>Proposition:</strong> For <span class="math notranslate nohighlight">\(j \in y_s+1, \ldots, N_s-(n_s-y_s)\)</span>, <span class="math notranslate nohighlight">\(a_s(j)\)</span> is monotone
decreasing in <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p><strong>Theorem:</strong> If <span class="math notranslate nohighlight">\(\sum_s y_s \le g \le N - \sum_s (n_s-y_s)\)</span>,</p>
<div class="math notranslate nohighlight">
\[
P(g) \le \chi_d(X_*^2(g)).
\]</div>
<p><strong>Proof:</strong>
Immediate from the definitions.</p>
<p>The theorem shows that a “greedy” approach finds a conservative <span class="math notranslate nohighlight">\(P\)</span>-value:
Construct the values <span class="math notranslate nohighlight">\(a_s(j)\)</span> and the set <span class="math notranslate nohighlight">\(\{b_k\}\)</span>.
Add the <span class="math notranslate nohighlight">\(S\)</span> values <span class="math notranslate nohighlight">\(\{a_s(x_k)\)</span> to the <span class="math notranslate nohighlight">\(g-g_y\)</span> largest elements of <span class="math notranslate nohighlight">\(\{b_k\}\)</span> and
multiply the sum by <span class="math notranslate nohighlight">\(-2\)</span>.
The upper tail probability of the chi-square distribution with <span class="math notranslate nohighlight">\(2S\)</span> degrees of
freedom is a conservative <span class="math notranslate nohighlight">\(P\)</span>-value for the hypothesis <span class="math notranslate nohighlight">\(G=g\)</span>.</p>
<p>A conservative upper <span class="math notranslate nohighlight">\(1-\alpha\)</span> confidence bound for <span class="math notranslate nohighlight">\(G\)</span> is the largest <span class="math notranslate nohighlight">\(g\)</span> for which
<span class="math notranslate nohighlight">\(P(g) \ge \alpha\)</span>.</p>
</section>
<section id="changing-the-direction-of-the-test">
<h2>Changing the direction of the test<a class="headerlink" href="#changing-the-direction-of-the-test" title="Permalink to this headline">#</a></h2>
<p>The test of the hypothesis <span class="math notranslate nohighlight">\(G=g\)</span> given above is a one-sided test against the alternative
<span class="math notranslate nohighlight">\(G &gt; g\)</span>: it rejects if the chance of observing “so few” good objects is small.</p>
<p>To test against the alternative <span class="math notranslate nohighlight">\(G &lt; g\)</span> (i.e., to reject if the chance of observing “so many”
good objects is small), exchange the role of “good” and “bad.”
The hypothesis <span class="math notranslate nohighlight">\(G &lt; g\)</span> is equivalent to the hypothesis <span class="math notranslate nohighlight">\((N-G) &gt; (N-g)\)</span>.</p>
<p>The resulting null hypothesis is <span class="math notranslate nohighlight">\(G = N-g\)</span>, and the data are <span class="math notranslate nohighlight">\(n_s - Y_s\)</span>.</p>
</section>
<section id="sampling-with-replacement">
<h2>Sampling with replacement<a class="headerlink" href="#sampling-with-replacement" title="Permalink to this headline">#</a></h2>
<p>The same approaches work for sampling with replacement.</p>
<p>For simplicity, assume that the population proportion <span class="math notranslate nohighlight">\(\pi = G/N\)</span> and the stratum proportions <span class="math notranslate nohighlight">\(\pi_s G_s/N_s\)</span> can be any numbers between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span>, not just multiples of <span class="math notranslate nohighlight">\(1/N\)</span> or <span class="math notranslate nohighlight">\(1/N_s\)</span>.</p>
<p>We observe <span class="math notranslate nohighlight">\(Y_s \sim \mathrm{Bin}(n_s, \pi_s)\)</span>, <span class="math notranslate nohighlight">\(s = 1, \ldots, S\)</span>.
The observations are independent.
The population proportion is <span class="math notranslate nohighlight">\(\pi := G/N = N^{-1}\sum_s \pi_s n_s\)</span>.</p>
<p>Define
$<span class="math notranslate nohighlight">\(
   p_s(\mu_s) := \mathbb{P} \{ Y_s \ge y_s || \pi_s = \mu_s \} =
   \sum_{y = y_s}^{n_s} \binom{n_s}{y} \mu_s^y (1-\mu_s)^{n_s-y}.
\)</span><span class="math notranslate nohighlight">\(
This is the \)</span>P<span class="math notranslate nohighlight">\(-value of the hypothesis \)</span>\pi_s = \mu_s<span class="math notranslate nohighlight">\( tested against the
alternative \)</span>\pi_s &gt; \mu_s$.</p>
<p>A test of the conjunction hypothesis <span class="math notranslate nohighlight">\(\pi_s = \mu_s\)</span>, <span class="math notranslate nohighlight">\(s=1, \ldots, S\)</span> can be constructed
using Fisher’s combining function:
Let <span class="math notranslate nohighlight">\(g_s = N_s\mu_s\)</span>, <span class="math notranslate nohighlight">\(s = 1, \ldots, S\)</span>.
If all <span class="math notranslate nohighlight">\(S\)</span> hypotheses are true, the distribution of
$<span class="math notranslate nohighlight">\(
  X^2(\vec{g}) := -2 \sum_{s=1}^S \log p_s(\mu_s)
\)</span><span class="math notranslate nohighlight">\(
is dominated by the chi-square distribution with \)</span>2S<span class="math notranslate nohighlight">\( degrees of freedom.
Let \)</span>\chi_d(z)<span class="math notranslate nohighlight">\( denote the survival function for the chi-sqare distribution with \)</span>d<span class="math notranslate nohighlight">\( degrees
of freedom, i.e., the chance that a random variable with the chi-square 
distribution with \)</span>d<span class="math notranslate nohighlight">\( degrees of freedom is greater than or equal to \)</span>z<span class="math notranslate nohighlight">\(.
Then a conservative \)</span>P<span class="math notranslate nohighlight">\(-value for the allocation \)</span>\vec{g}<span class="math notranslate nohighlight">\( is
\)</span><span class="math notranslate nohighlight">\(
   P(\vec{g}) = \chi_{2S}(X^2(\vec{\mu})).
\)</span><span class="math notranslate nohighlight">\(
The allocation \)</span>\vec{\mu}<span class="math notranslate nohighlight">\( that maximizes the \)</span>P<span class="math notranslate nohighlight">\(-value
is the allocation that minimizes \)</span>X^2(\vec{g})<span class="math notranslate nohighlight">\( and satisfies \)</span>\sum_s \mu_s = g<span class="math notranslate nohighlight">\(.
Equivalently, it is the allocation that maximizes \)</span>\sum_{s=1}^S \log p_s(g_s)$.</p>
<p><strong>Lemma.</strong> The Binomial pdf is log concave in <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p><strong>Proof.</strong></p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\frac{d^2}{dp^2} \log \left [ \binom{n}{k}p^k(1-p)^{n-k} \right ] &amp; = \frac{d^2}{dp^2} \left [ C + k\log p + (n-k)\log(1-p) \right ] \\
&amp;= \frac{d}{dp} (k/p - (n-k)/(1-p)) \\
&amp;= -k/p^2 - (n-k)/(1-p)^2 &lt; 0. \Box
\end{align*}
\end{split}\]</div>
</section>
<section id="open-questions">
<h2>Open questions<a class="headerlink" href="#open-questions" title="Permalink to this headline">#</a></h2>
<p>The Wendell-Schmee test coincides exactly with the unadjusted new test (i.e.,
using the joint probability <em>without</em> calibrating it with Fisher’s combining function)
for small observed counts. The optimal parameter values
are identical, and the Wendell-Schmee <span class="math notranslate nohighlight">\(P\)</span>-value is equal to the tail probability in the new test
before Fisher’s adjustment.
Why?</p>
<p>For what observations is the optimal allocation the same for the two tests?</p>
<p>Can a similar constructive/greedy
approach find the optimizer (or a bound) for the Wendell-Schmee test?
(Implausible because of the lack of convexity, at least in the original parametrization.)</p>
<p>What is the empirical coverage of the two methods?
What’s the worst-case?</p>
<p>When is the new method sharper than Wendell-Schmee? (Seems to be when the strata
are heterogeneous.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Install permute and cryptorandom in the current kernel if needed</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="o">!{</span>sys.executable<span class="o">}</span><span class="w"> </span>-m<span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>permute<span class="w"> </span>--user
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Requirement already satisfied: permute in /Users/stark/.local/lib/python3.10/site-packages (0.2)
Requirement already satisfied: scipy&gt;=1.6 in /opt/anaconda3/lib/python3.10/site-packages (from permute) (1.7.3)
Requirement already satisfied: cryptorandom&gt;=0.3 in /opt/anaconda3/lib/python3.10/site-packages (from permute) (0.3)
Requirement already satisfied: numpy&gt;=1.20 in /opt/anaconda3/lib/python3.10/site-packages (from permute) (1.21.5)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">binom</span><span class="p">,</span> <span class="n">hypergeom</span><span class="p">,</span> <span class="n">chi2</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">permute.utils</span> <span class="kn">import</span> <span class="n">binom_conf_interval</span><span class="p">,</span> <span class="n">hypergeom_conf_interval</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># New utility functions</span>

<span class="k">def</span> <span class="nf">fisher_log</span><span class="p">(</span><span class="n">log_p</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Fisher&#39;s combining function for the log of independent P-values</span>
<span class="sd">    </span>
<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    log_p : np.array or float</span>
<span class="sd">        vector of logarithms of independent P-values or sum of the logs</span>
<span class="sd">    df : int</span>
<span class="sd">        twice the number of log P-values in the sum. </span>
<span class="sd">        Required if log_p is a scalar; otherwise, inferred from len(log_p)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : float</span>
<span class="sd">        combined P-value (not on a log scale)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_p</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>  <span class="c1"># log_p is already the sum; need sensible df</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;df&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">df</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">df</span><span class="si">=}</span><span class="s1"> incorrect or not set&#39;</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># there&#39;s a vector of log P-values; df is twice its length</span>
        <span class="n">df</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">log_p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">log_p</span><span class="p">),</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bars_stars</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">good</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate all allocations of `good` 1s across the strata</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        stratum sizes</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        number of 1s found in the sampl from each stratum</span>
<span class="sd">    good : int</span>
<span class="sd">        number of 1s to distribute across the strata</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    generator that iterates over all allocations</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n_strata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span>
    <span class="n">barsNstars</span> <span class="o">=</span> <span class="n">good</span> <span class="o">+</span> <span class="n">n_strata</span>
    <span class="n">bars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n_strata</span> <span class="o">+</span> <span class="p">[</span><span class="n">barsNstars</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">([</span><span class="n">bars</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_strata</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">bars</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">barsNstars</span><span class="p">),</span> <span class="n">n_strata</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(((</span><span class="n">bars</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">strata</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="ow">and</span> \
            <span class="p">(</span><span class="n">bars</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">found</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_strata</span><span class="p">)))</span>            


<span class="k">class</span> <span class="nc">StratifiedBinary</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    allocation of 1s to strata</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    strata : numpy array of ints</span>
<span class="sd">        stratum sizes</span>
<span class="sd">    sams : numpy array of ints</span>
<span class="sd">        sample sizes</span>
<span class="sd">    found : numpy array of ints</span>
<span class="sd">        number of 1s in the sample from each stratum</span>
<span class="sd">    alloc : numpy array of ints</span>
<span class="sd">        initial allocation of 1s to strata (found)</span>
<span class="sd">    log_p : numpy array of floats</span>
<span class="sd">        tail probabilities for the allocation</span>
<span class="sd">    next_up : numpy array of floats</span>
<span class="sd">        log of the probability multipliers for including an additional 1 in each stratum</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">found</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alloc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">next_up</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">strata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sams</span> <span class="o">=</span> <span class="n">sams</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">found</span> <span class="o">=</span> <span class="n">found</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_p</span> <span class="o">=</span> <span class="n">log_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_up</span> <span class="o">=</span> <span class="n">next_up</span>
    
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">strata</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">sams</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">found</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">alloc</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">log_p</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">next_up</span><span class="si">=}</span><span class="s1">&#39;</span>        
    
    <span class="k">def</span> <span class="nf">allocate_first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        initialize the allocation of 1s to strata and ingredients for constructive max</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True</span>
<span class="sd">        </span>
<span class="sd">        Side effects</span>
<span class="sd">        ------------</span>
<span class="sd">        initializes the allocation to its minimal feasible values</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">found</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>                    <span class="c1"># allocation that maximizes the P-value so far</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">hypergeom</span><span class="o">.</span><span class="n">logsf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">found</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> \
                             <span class="bp">self</span><span class="o">.</span><span class="n">sams</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">))])</span>  <span class="c1"># stratumwise log tail probabilities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">sams</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">found</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> \
                                 <span class="k">else</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">hypergeom</span><span class="o">.</span><span class="n">logsf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">found</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>\
                                <span class="bp">self</span><span class="o">.</span><span class="n">sams</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_p</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">))])</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">allocate_next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        allocate an additional 1 to the stratum that gives largest tail probability</span>

<span class="sd">        updates alloc and next_up in place</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        success: bool</span>
<span class="sd">            true unless there&#39;s nothing left to allocate</span>
<span class="sd">        </span>
<span class="sd">        Side effects</span>
<span class="sd">        ------------</span>
<span class="sd">        updates alloc and next_up</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">big</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_up</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">big</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_p</span><span class="p">[</span><span class="n">big</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">hypergeom</span><span class="o">.</span><span class="n">logsf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">found</span><span class="p">[</span><span class="n">big</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">[</span><span class="n">big</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">big</span><span class="p">],</span> 
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">sams</span><span class="p">[</span><span class="n">big</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_up</span><span class="p">[</span><span class="n">big</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">big</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">[</span><span class="n">big</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">sams</span><span class="p">[</span><span class="n">big</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">found</span><span class="p">[</span><span class="n">big</span><span class="p">]</span>
                             <span class="k">else</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">hypergeom</span><span class="o">.</span><span class="n">logsf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">found</span><span class="p">[</span><span class="n">big</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">[</span><span class="n">big</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">big</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> 
                             <span class="bp">self</span><span class="o">.</span><span class="n">sams</span><span class="p">[</span><span class="n">big</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_p</span><span class="p">[</span><span class="n">big</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_up</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">fisher_p</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fisher P-value</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">fisher_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_p</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        total 1s allocated</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">n_strata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        number of strata</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Maximum P-values over allocations </span>
            
<span class="k">def</span> <span class="nf">strat_test_brute</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sams</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">good</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    p-value of the hypothesis that the number of 1s in a binary population is </span>
<span class="sd">    less than or equal to `good`, from a stratified random sample.</span>
<span class="sd">    </span>
<span class="sd">    Assumes that a simple random sample of size sams[s] was drawn from stratum s, </span>
<span class="sd">    which contains strata[s] objects in all.</span>
<span class="sd">    </span>
<span class="sd">    The P-value is the maximum Fisher combined P-value across strata</span>
<span class="sd">    over all allocations of good 1s among the strata. The allocations are</span>
<span class="sd">    enumerated using Feller&#39;s &quot;bars and stars&quot; construction, constrained to honor the</span>
<span class="sd">    stratum sizes and the data (each stratum can contain no more 1s than it has items in all</span>
<span class="sd">    minus the observed number of 0s, nor fewer &quot;good&quot; items than the sample contains).</span>
<span class="sd">    </span>
<span class="sd">    The number of allocations grows combinatorially: there can be as many as</span>
<span class="sd">    [(#strata + #1s) choose (#strata-1)] allocations, making the brute-force approach computationally </span>
<span class="sd">    infeasible when the number of strata and/or the number of 1s is large.</span>
<span class="sd">    </span>
<span class="sd">    The test is a union-intersection test: the null hypothesis is the union over allocations</span>
<span class="sd">    of the intersection across strata of the hypothesis that the number of 1s</span>
<span class="sd">    in the stratum is less than or equal to a constant.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        sizes of the strata</span>
<span class="sd">    sams : list of ints</span>
<span class="sd">        sample sizes from the strata</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        the numbers of 1s found in the samples from the strata</span>
<span class="sd">    good : int</span>
<span class="sd">        the hypothesized total number of 1s in the population</span>
<span class="sd">    kwargs : keyword arguments for this function and the functions it calls</span>
<span class="sd">        alternative : string {&#39;lower&#39;, &#39;upper&#39;}</span>
<span class="sd">            test against the alternative that the true number of 1s is less than good (lower)</span>
<span class="sd">            or greater than good (&#39;upper&#39;). Default &#39;lower&#39;</span>
<span class="sd">        combining_function : callable </span>
<span class="sd">            combining function; default is fisher_log. </span>
<span class="sd">            kwarg is also passed to combining_function</span>
<span class="sd">        cheap_combiner : callable</span>
<span class="sd">            monotone increasing function of the combining function. </span>
<span class="sd">            Default np.sum if combining_function == fisher_log</span>
<span class="sd">            kwarg also passed to cheap_combiner</span>
<span class="sd">        warn : int</span>
<span class="sd">            warn if the number of allocations exceeds this. Default 10**7        </span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    p : float</span>
<span class="sd">        maximum combined p-value over all ways of allocating good &quot;good&quot; objects</span>
<span class="sd">        among the strata, honoring the stratum sizes.        </span>
<span class="sd">    alloc : list</span>
<span class="sd">        an allocation that attains the maximum p-value</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alternative&#39;</span><span class="p">,</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span><span class="s1">&#39;upper&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;alternative </span><span class="si">{</span><span class="n">alternative</span><span class="si">}</span><span class="s1"> not implemented&#39;</span>
    <span class="n">alloc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">sams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">strata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">good</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">found</span><span class="p">):</span>     
        <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span> <span class="k">else</span> <span class="mi">1</span> 
    <span class="k">elif</span> <span class="n">good</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sams</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">found</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>  
        <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>                   <span class="c1"># exchange roles of 1s and 0s</span>
            <span class="n">compl</span> <span class="o">=</span> <span class="n">sams</span> <span class="o">-</span> <span class="n">found</span>                     <span class="c1"># 0s found </span>
            <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">good</span>              <span class="c1"># total 0s hypothesized</span>
            <span class="n">kwargs_c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">kwargs_c</span><span class="p">[</span><span class="s1">&#39;alternative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">alloc_c</span> <span class="o">=</span> <span class="n">strat_test_brute</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">compl</span><span class="p">,</span> <span class="n">bad</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_c</span><span class="p">)</span>
            <span class="n">alloc</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">alloc_c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">strata</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alloc_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span>   <span class="c1"># initial value for the max</span>
            <span class="n">n_strata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="n">good</span><span class="o">+</span><span class="n">n_strata</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_strata</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">combining_function</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;combining_function&#39;</span><span class="p">,</span> <span class="n">fisher_log</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">combining_function</span> <span class="o">==</span> <span class="n">fisher_log</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;df&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_strata</span>
                <span class="n">cheap_combiner</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p_vec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_vec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cheap_combiner</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cheap_combiner&#39;</span><span class="p">,</span> <span class="n">combining_function</span><span class="p">)</span>
            <span class="n">warn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parts</span> <span class="o">&gt;=</span> <span class="n">warn</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;warning--large number of allocations: </span><span class="si">{</span><span class="n">parts</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">alloc</span> <span class="o">=</span> <span class="n">found</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">bars_stars</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">):</span>
                <span class="n">p_new</span> <span class="o">=</span> <span class="n">cheap_combiner</span><span class="p">(</span> 
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">hypergeom</span><span class="o">.</span><span class="n">logsf</span><span class="p">(</span><span class="n">found</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">part</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_strata</span><span class="p">)]),</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p_new</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">:</span>
                    <span class="n">alloc</span> <span class="o">=</span> <span class="n">part</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">p_new</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">combining_function</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">alloc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">alloc</span><span class="p">))</span>
    
<span class="k">def</span> <span class="nf">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sams</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">good</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    P-value for the hypothesis that the number of 1s in a binary population is not </span>
<span class="sd">    greater than (or not less than) a hypothesized value, based on a stratified </span>
<span class="sd">    random sample without replacement.</span>
<span class="sd">    </span>
<span class="sd">    Uses the fast algorithm to find the P-value constructively.</span>
<span class="sd">    </span>
<span class="sd">    Uses Fisher&#39;s combining function to combine stratum-level P-values.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------    </span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        stratum sizes</span>
<span class="sd">    sams : list of ints</span>
<span class="sd">        sample sizes in the strata</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        number of ones found in each stratum in each sample</span>
<span class="sd">    good : int</span>
<span class="sd">        hypothesized number of ones in the population</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        alternative : string {&#39;lower&#39;, &#39;upper&#39;} default &#39;lower&#39;</span>
<span class="sd">            test against the alternative that the true number of 1s is less than (lower) </span>
<span class="sd">            or greater than (upper) the hypothesized number, good</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    p : float</span>
<span class="sd">        P-value</span>
<span class="sd">    alloc : list</span>
<span class="sd">        an allocation that attains the maximum p-value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alternative&#39;</span><span class="p">,</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;alternative </span><span class="si">{</span><span class="n">alternative</span><span class="si">}</span><span class="s1"> not implemented&#39;</span>
    <span class="n">strata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">sams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">good</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">good</span><span class="p">)</span>
    <span class="n">alloc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">good</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">found</span><span class="p">):</span>     
        <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span> <span class="k">else</span> <span class="mi">1</span> 
    <span class="k">elif</span> <span class="n">good</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sams</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">found</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>                  <span class="c1"># exchange roles of &quot;good&quot; and &quot;bad&quot;</span>
            <span class="n">compl</span> <span class="o">=</span> <span class="n">sams</span> <span class="o">-</span> <span class="n">found</span>                    <span class="c1"># bad items found </span>
            <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">good</span>             <span class="c1"># total bad items hypothesized</span>
            <span class="n">kwargs_c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">kwargs_c</span><span class="p">[</span><span class="s1">&#39;alternative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">alloc_c</span> <span class="o">=</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">compl</span><span class="p">,</span> <span class="n">bad</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_c</span><span class="p">)</span>
            <span class="n">alloc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">alloc_c</span> <span class="ow">is</span> <span class="kc">None</span> 
                          <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">strata</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alloc_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>  
            <span class="k">if</span> <span class="n">good</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="ow">or</span> <span class="n">good</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span> <span class="o">-</span> <span class="n">sams</span> <span class="o">+</span> <span class="n">found</span><span class="p">):</span> <span class="c1"># impossible</span>
                <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>  
            <span class="k">elif</span> <span class="n">good</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="o">-</span><span class="n">sams</span><span class="o">+</span><span class="n">found</span><span class="p">):</span> <span class="c1"># the &quot;packed&quot; allocation guarantees this outcome or more 1s</span>
                <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">alloc</span> <span class="o">=</span> <span class="n">strata</span><span class="o">-</span><span class="n">sams</span><span class="o">+</span><span class="n">found</span>      
            <span class="k">else</span><span class="p">:</span>                                   <span class="c1"># outcome is possible but not certain under the composite null </span>
                <span class="n">optimal</span> <span class="o">=</span> <span class="n">StratifiedBinary</span><span class="p">(</span><span class="n">strata</span><span class="o">=</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="o">=</span><span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="o">=</span><span class="n">found</span><span class="p">)</span>
                <span class="n">optimal</span><span class="o">.</span><span class="n">allocate_first</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">optimal</span><span class="o">.</span><span class="n">total</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">good</span><span class="p">:</span>
                    <span class="n">optimal</span><span class="o">.</span><span class="n">allocate_next</span><span class="p">()</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">optimal</span><span class="o">.</span><span class="n">fisher_p</span><span class="p">()</span>
                <span class="n">alloc</span> <span class="o">=</span> <span class="n">optimal</span><span class="o">.</span><span class="n">alloc</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">alloc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">alloc</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Confidence intervals</span>

<span class="k">def</span> <span class="nf">strat_ci_bisect</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sams</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Confidence bound on the number of ones in a stratified binary population,</span>
<span class="sd">    based on a stratified random sample without replacement</span>
<span class="sd">    </span>
<span class="sd">    If alternative==&#39;lower&#39;, finds an upper confidence bound.</span>
<span class="sd">    If alternative==&#39;upper&#39;, finds a lower confidence bound.</span>

<span class="sd">    Uses an integer bisection search to find an exact confidence bound.</span>
<span class="sd">    The starting upper endpoint for the search is the unbiased estimate</span>
<span class="sd">    of the number of ones in the population. That could be refined in various</span>
<span class="sd">    ways to improve efficiency.</span>
<span class="sd">    </span>
<span class="sd">    The lower endpoint for the search is the Šidák joint lower confidence bounds,</span>
<span class="sd">    which should be more conservative than the exact bound.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------    </span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        stratum sizes</span>
<span class="sd">    sams : list of ints</span>
<span class="sd">        sample sizes in the strata</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        number of ones found in each stratum in each sample</span>
<span class="sd">    kwargs:</span>
<span class="sd">        alternative : string in {&#39;lower&#39;, &#39;upper&#39;}</span>
<span class="sd">            if alternative==&#39;lower&#39;, finds an upper confidence bound.</span>
<span class="sd">            if alternative==&#39;upper&#39;, finds a lower confidence bound.</span>
<span class="sd">            While this is not mnemonic, it corresponds to the sidedness of the tests</span>
<span class="sd">            that are inverted to get the confidence bound.</span>
<span class="sd">        cl : float</span>
<span class="sd">            confidence level. Assumed to be at least 0.5. Default 0.95.</span>
<span class="sd">        p_value : callable</span>
<span class="sd">            method for computing the p-value</span>
<span class="sd">        kwargs is also passed to p_value</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    b : int</span>
<span class="sd">        confidence bound</span>
<span class="sd">    alloc : list of ints</span>
<span class="sd">        allocation that attains the confidence bound</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cl&#39;</span><span class="p">,</span><span class="mf">0.95</span><span class="p">)</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;p_value&#39;</span><span class="p">,</span> <span class="n">strat_test_brute</span><span class="p">)</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alternative&#39;</span><span class="p">,</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="n">strata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">sams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;alternative </span><span class="si">{</span><span class="n">alternative</span><span class="si">}</span><span class="s1"> not implemented&#39;</span>    
    <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>  <span class="c1"># interchange good and bad</span>
        <span class="n">compl</span> <span class="o">=</span> <span class="n">sams</span><span class="o">-</span><span class="n">found</span>      <span class="c1"># bad items found</span>
        <span class="n">kwargs_c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_c</span><span class="p">[</span><span class="s1">&#39;alternative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
        <span class="n">cb</span><span class="p">,</span> <span class="n">alloc_c</span> <span class="o">=</span> <span class="n">strat_ci_bisect</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">compl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_c</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">cb</span>    <span class="c1"># good from bad</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">strata</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alloc_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cl_sidak</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">))</span>  <span class="c1"># Šidák adjustment</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">cl</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">hypergeom_conf_interval</span><span class="p">(</span> \
                <span class="n">sams</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">cl</span><span class="o">=</span><span class="n">cl_sidak</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> \
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">))))</span> <span class="c1"># Šidák should give a lower bound</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">)))</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># expected good</span>
        <span class="n">p_a</span><span class="p">,</span> <span class="n">alloc_a</span> <span class="o">=</span> <span class="n">p_value</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
        <span class="n">p_b</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">p_value</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
        <span class="n">tot_found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">found</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">p_a</span> <span class="o">&gt;</span> <span class="n">tail</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">tot_found</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">p_a</span><span class="p">,</span> <span class="n">alloc_a</span> <span class="o">=</span> <span class="n">p_value</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p_a</span> <span class="o">&gt;</span> <span class="n">tail</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc_a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">b</span><span class="o">-</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">p_c</span><span class="p">,</span> <span class="n">alloc_c</span> <span class="o">=</span> <span class="n">p_value</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p_c</span> <span class="o">&gt;</span> <span class="n">tail</span><span class="p">:</span>
                    <span class="n">b</span><span class="p">,</span> <span class="n">p_b</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">p_c</span><span class="p">,</span> <span class="n">alloc_c</span>
                <span class="k">elif</span> <span class="n">p_c</span> <span class="o">&lt;</span> <span class="n">tail</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">p_a</span><span class="p">,</span> <span class="n">alloc_a</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">p_c</span><span class="p">,</span> <span class="n">alloc_c</span>
                <span class="k">elif</span> <span class="n">p_c</span> <span class="o">==</span> <span class="n">tail</span><span class="p">:</span>
                    <span class="n">b</span><span class="p">,</span> <span class="n">p_b</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">p_c</span><span class="p">,</span> <span class="n">alloc_c</span>
                    <span class="k">break</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">strat_ci_search</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sams</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Confidence bound on the number of ones in a stratified population,</span>
<span class="sd">    based on a stratified random sample (without replacement) from</span>
<span class="sd">    the population.</span>
<span class="sd">        </span>
<span class="sd">    If alternative==&#39;lower&#39;, finds an upper confidence bound.</span>
<span class="sd">    If alternative==&#39;upper&#39;, finds a lower confidence bound.</span>
<span class="sd">    </span>
<span class="sd">    Searches for the allocation of items that attains the confidence bound</span>
<span class="sd">    by increasing the number of ones from the minimum consistent</span>
<span class="sd">    with the data (total found in the sample) until the P-value is greater</span>
<span class="sd">    than 1-cl.</span>
<span class="sd">    </span>
<span class="sd">    Uses the fast method for finding the maximum P-value for Fisher&#39;s combining function</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------    </span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        stratum sizes</span>
<span class="sd">    sams : list of ints</span>
<span class="sd">        sample sizes in the strata</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        number of ones found in each stratum in each sample</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        alternative : string {&#39;lower&#39;, &#39;upper&#39;} Default &#39;lower&#39;</span>
<span class="sd">            if alternative==&#39;lower&#39;, finds an upper confidence bound.</span>
<span class="sd">            if alternative==&#39;upper&#39;, finds a lower confidence bound.</span>
<span class="sd">            While this is not mnemonic, it corresponds to the sidedness of the tests</span>
<span class="sd">            that are inverted to get the confidence bound.</span>
<span class="sd">        cl : float Default 0.95</span>
<span class="sd">            confidence level. Assumed to be at least 50%.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    cb : int</span>
<span class="sd">        confidence bound</span>
<span class="sd">    alloc : list of ints</span>
<span class="sd">        allocation that attains the confidence bound (give or take one item)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cl&#39;</span><span class="p">,</span><span class="mf">0.95</span><span class="p">)</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alternative&#39;</span><span class="p">,</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;alternative </span><span class="si">{</span><span class="n">alternative</span><span class="si">}</span><span class="s1"> not implemented&#39;</span>
    <span class="n">strata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">sams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>  <span class="c1"># interchange good and bad</span>
        <span class="n">kwargs_c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_c</span><span class="p">[</span><span class="s1">&#39;alternative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
        <span class="n">compl</span> <span class="o">=</span> <span class="n">sams</span><span class="o">-</span><span class="n">found</span>  <span class="c1"># bad items found</span>
        <span class="n">cb</span><span class="p">,</span> <span class="n">alloc_c</span> <span class="o">=</span> <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">compl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_c</span><span class="p">)</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">cb</span>    <span class="c1"># good from bad</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">strata</span> <span class="o">-</span> <span class="n">alloc_c</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="o">*</span><span class="n">found</span><span class="o">/</span><span class="n">sams</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># expected good</span>
        <span class="n">p_attained</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">p_attained</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">-</span><span class="n">cl</span><span class="p">:</span>
            <span class="n">cb</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">p_attained</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
        <span class="n">cb</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">p_attained</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cb</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sams</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Confidence bound on the number of ones in a population,</span>
<span class="sd">    based on a stratified random sample (without replacement) from</span>
<span class="sd">    the population.</span>
<span class="sd">    </span>
<span class="sd">    If alternative==&#39;lower&#39;, finds an upper confidence bound.</span>
<span class="sd">    If alternative==&#39;upper&#39;, finds a lower confidence bound.</span>
<span class="sd">    </span>
<span class="sd">    Constructs the confidence bound directly by constructing the</span>
<span class="sd">    allocation of the maximum number of ones that would not be</span>
<span class="sd">    rejected at (conservative) level 1-cl.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------    </span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        stratum sizes</span>
<span class="sd">    sams : list of ints</span>
<span class="sd">        sample sizes in the strata</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        number of ones found in each stratum in each sample</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        alternative : string {&#39;lower&#39;, &#39;upper&#39;} default &#39;lower&#39;</span>
<span class="sd">            if alternative==&#39;lower&#39;, finds an upper confidence bound.</span>
<span class="sd">            if alternative==&#39;upper&#39;, finds a lower confidence bound.</span>
<span class="sd">            While this is not mnemonic, it corresponds to the sidedness of the tests</span>
<span class="sd">            that are inverted to get the confidence bound.</span>
<span class="sd">        cl : float default 0.95</span>
<span class="sd">            confidence level</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    cb : int</span>
<span class="sd">        confidence bound</span>
<span class="sd">    alloc : list of ints</span>
<span class="sd">        allocation that attains the confidence bound (give or take one item)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cl&#39;</span><span class="p">,</span><span class="mf">0.95</span><span class="p">)</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alternative&#39;</span><span class="p">,</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="n">strata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">sams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;alternative </span><span class="si">{</span><span class="n">alternative</span><span class="si">}</span><span class="s1"> not implemented&#39;</span>
    <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>  <span class="c1"># interchange role of good and bad</span>
        <span class="n">compl</span> <span class="o">=</span> <span class="n">sams</span> <span class="o">-</span> <span class="n">found</span>  <span class="c1"># bad found</span>
        <span class="n">kwargs_c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_c</span><span class="p">[</span><span class="s1">&#39;alternative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
        <span class="n">cb</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">compl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_c</span><span class="p">)</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">strata</span> <span class="o">-</span> <span class="n">alloc</span>
    <span class="k">else</span><span class="p">:</span>                
        <span class="n">threshold</span> <span class="o">=</span> <span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1"># g is in the confidence set if </span>
        <span class="c1">#          chi2.sf(-2*log(p), df=2*len(strata)) &gt;= 1-cl</span>
        <span class="c1">#  i.e.,   -2*log(p) &lt;=  chi2.ppf(cl, df)</span>
        <span class="c1">#  i.e.,   log(p) &gt;= -chi2.ppf(cl, df)/2</span>
        <span class="n">optimal</span> <span class="o">=</span> <span class="n">StratifiedBinary</span><span class="p">(</span><span class="n">strata</span><span class="o">=</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="o">=</span><span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="o">=</span><span class="n">found</span><span class="p">)</span>
        <span class="n">optimal</span><span class="o">.</span><span class="n">allocate_first</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">optimal</span><span class="o">.</span><span class="n">log_p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">optimal</span><span class="o">.</span><span class="n">allocate_next</span><span class="p">()</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">optimal</span><span class="o">.</span><span class="n">alloc</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alloc</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># older methods</span>

<span class="k">def</span> <span class="nf">strat_p_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sams</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">hypo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds Wendell-Schmee P-value for the hypothesized population counts `hypo` for </span>
<span class="sd">    simple random samples of sizes `sams` from strata of sizes `strata` if </span>
<span class="sd">    `found` 1s are found in the samples from the strata.</span>
<span class="sd">        </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------    </span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        stratum sizes</span>
<span class="sd">    sams : list of ints</span>
<span class="sd">        sample sizes from the strata</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        number of ones found in each stratum in each sample</span>
<span class="sd">    hypo : list of ints</span>
<span class="sd">        hypothesized numbers of ones the strata</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    p : float</span>
<span class="sd">        tail probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alternative&#39;</span><span class="p">,</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>                     <span class="c1"># exchange roles of &quot;good&quot; and &quot;bad&quot;</span>
        <span class="n">kwargs_c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_c</span><span class="p">[</span><span class="s1">&#39;alternative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="n">compl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">)</span>   <span class="c1"># bad items found </span>
        <span class="n">hypo_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypo</span><span class="p">)</span> <span class="c1"># total bad items hypothesized</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">strat_p_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">compl</span><span class="p">,</span> <span class="n">hypo_c</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_c</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>    
        <span class="n">p_hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">,</span> <span class="n">st</span><span class="o">=</span><span class="n">strata</span><span class="p">,</span> <span class="n">sa</span><span class="o">=</span><span class="n">sams</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sa</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="c1"># pooled estimate</span>
        <span class="n">p_hat_0</span> <span class="o">=</span> <span class="n">p_hat</span><span class="p">(</span><span class="n">found</span><span class="p">)</span>
        <span class="n">per_strat</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span>
        <span class="n">strat_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">p_hat_0</span><span class="o">/</span><span class="n">per_strat</span><span class="p">)</span>
        <span class="n">lo_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strat_max</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">p_hat</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">p_hat_0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">hypergeom</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">hypo</span><span class="p">,</span> <span class="n">sams</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lo_t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="k">def</span> <span class="nf">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sams</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">good</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find p-value of the hypothesis that the number G of &quot;good&quot; objects in a </span>
<span class="sd">    stratified population is less than or equal to good, using a stratified</span>
<span class="sd">    random sample.</span>
<span class="sd">    </span>
<span class="sd">    Assumes that a simple random sample of size sams[s] was drawn from stratum s, </span>
<span class="sd">    which contains strata[s] objects in all.</span>
<span class="sd">    </span>
<span class="sd">    The P-value is the maximum Windell-Schmee P-value over all allocations of </span>
<span class="sd">    good objects among the strata. The allocations are enumerated using Feller&#39;s </span>
<span class="sd">    &quot;bars and stars&quot; construction, constrained to honor the stratum sizes (each </span>
<span class="sd">    stratum can contain no more &quot;good&quot; items than it has items in all, nor fewer </span>
<span class="sd">    &quot;good&quot; items than the sample contains).</span>
<span class="sd">    </span>
<span class="sd">    The number of allocations grows combinatorially: there can be as many as</span>
<span class="sd">    [(#strata + #good items) choose (#strata-1)] allocations, making the brute-force</span>
<span class="sd">    approach computationally infeasible when the number of strata and/or the number of</span>
<span class="sd">    good items is large.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        sizes of the strata. One int per stratum.</span>
<span class="sd">    sams : list of ints</span>
<span class="sd">        the sample sizes from each stratum</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        the numbers of &quot;good&quot; items found in the samples from the strata</span>
<span class="sd">    good : int</span>
<span class="sd">        the hypothesized total number of &quot;good&quot; objects in the population</span>
<span class="sd">    alternative : string {&#39;lower&#39;, &#39;upper&#39;}</span>
<span class="sd">        test against the alternative that the true value is less than good (lower)</span>
<span class="sd">        or greater than good (upper)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    p : float</span>
<span class="sd">        maximum combined p-value over all ways of allocating good &quot;good&quot; objects</span>
<span class="sd">        among the strata, honoring the stratum sizes.        </span>
<span class="sd">    alloc : list</span>
<span class="sd">        the allocation that attained the maximum p-value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alternative&#39;</span><span class="p">,</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>                   <span class="c1"># exchange roles of &quot;good&quot; and &quot;bad&quot;</span>
        <span class="n">compl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="c1"># bad items found </span>
        <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">good</span>              <span class="c1"># total bad items hypothesized</span>
        <span class="n">kwargs_c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_c</span><span class="p">[</span><span class="s1">&#39;alternative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">compl</span><span class="p">,</span> <span class="n">bad</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>        
    <span class="n">alloc</span> <span class="o">=</span> <span class="n">found</span> <span class="c1"># start with what you see</span>
    <span class="n">good</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">good</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">good</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">found</span><span class="p">):</span>     
        <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span> <span class="k">else</span> <span class="mi">1</span> 
    <span class="k">elif</span> <span class="n">good</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sams</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">found</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># use Feller&#39;s &quot;bars and stars&quot; enumeration of combinations, constrained</span>
        <span class="n">p_hat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">,</span> <span class="n">st</span><span class="o">=</span><span class="n">strata</span><span class="p">,</span> <span class="n">sa</span><span class="o">=</span><span class="n">sams</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sa</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="c1"># pooled estimate</span>
        <span class="n">p_hat_0</span> <span class="o">=</span> <span class="n">p_hat</span><span class="p">(</span><span class="n">found</span><span class="p">)</span>
        <span class="n">per_strat</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span>
        <span class="n">strat_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">p_hat_0</span><span class="o">/</span><span class="n">per_strat</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># initial value for the max</span>
        <span class="n">n_strata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="n">good</span><span class="o">+</span><span class="n">n_strata</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_strata</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">bars_stars</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">):</span>
            <span class="n">lo_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strat_max</span><span class="p">])</span> \
                    <span class="k">if</span> <span class="n">p_hat</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">p_hat_0</span><span class="p">)</span>
            <span class="n">p_new</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lo_t</span><span class="p">:</span>
                <span class="n">p_temp</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">)):</span>
                    <span class="n">p_temp</span> <span class="o">*=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">hypergeom</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">part</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                <span class="n">p_new</span> <span class="o">+=</span> <span class="n">p_temp</span>
            <span class="k">if</span> <span class="n">p_new</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">alloc</span> <span class="o">=</span> <span class="n">part</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p_new</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">strat_ci_wright</span><span class="p">(</span><span class="n">strata</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sams</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">found</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Confidence bound on the number of ones in a stratified population,</span>
<span class="sd">    based on a stratified random sample (without replacement) from</span>
<span class="sd">    the population.</span>
<span class="sd">    </span>
<span class="sd">    If alternative==&#39;lower&#39;, finds an upper confidence bound.</span>
<span class="sd">    If alternative==&#39;upper&#39;, finds a lower confidence bound.</span>
<span class="sd">    </span>
<span class="sd">    Constructs the confidence bound by finding Šidák multiplicity-adjusted</span>
<span class="sd">    joint lower confidence bounds for the number of ones in each stratum.</span>
<span class="sd">    </span>
<span class="sd">    This approach is mentioned in Wright, 1991.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------    </span>
<span class="sd">    strata : list of ints</span>
<span class="sd">        stratum sizes</span>
<span class="sd">    sams : list of ints</span>
<span class="sd">        sample sizes in the strata</span>
<span class="sd">    found : list of ints</span>
<span class="sd">        number of ones found in each stratum in each sample</span>
<span class="sd">    alternative : string {&#39;lower&#39;, &#39;upper&#39;}</span>
<span class="sd">        if alternative==&#39;lower&#39;, finds an upper confidence bound.</span>
<span class="sd">        if alternative==&#39;upper&#39;, finds a lower confidence bound.</span>
<span class="sd">        While this is not mnemonic, it corresponds to the sidedness of the tests</span>
<span class="sd">        that are inverted to get the confidence bound.</span>
<span class="sd">    cl : float</span>
<span class="sd">        confidence level</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    cb : int</span>
<span class="sd">        confidence bound</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alternative&#39;</span><span class="p">,</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">]</span>
    <span class="n">inx</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cl&#39;</span><span class="p">,</span><span class="mf">0.95</span><span class="p">)</span>
    <span class="n">cl_sidak</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">))</span>  <span class="c1"># Šidák-adjusted confidence level per stratum</span>
    <span class="n">cb</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">hypergeom_conf_interval</span><span class="p">(</span>
                <span class="n">sams</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">cl</span><span class="o">=</span><span class="n">cl_sidak</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)[</span><span class="n">inx</span><span class="p">]</span> 
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">cb</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_strat_test</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">strata</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]</span>
    <span class="n">sams</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
    <span class="n">found</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">)):</span>
        <span class="n">compl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">60</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">j</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">alternative</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">p_exact</span> <span class="o">=</span> <span class="n">strat_test_brute</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
                <span class="n">p_exact_c</span> <span class="o">=</span> <span class="n">strat_test_brute</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">compl</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
                <span class="n">p_fast</span> <span class="o">=</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
                <span class="n">p_fast_c</span>  <span class="o">=</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">compl</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">p_exact</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_fast</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">p_exact_c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_fast_c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_strat_ci</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">strata</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]]</span>
    <span class="n">sams</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
    <span class="n">found</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span><span class="s1">&#39;upper&#39;</span><span class="p">]:</span>
            <span class="n">brute</span> <span class="o">=</span> <span class="n">strat_ci_bisect</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
            <span class="n">fast_s</span> <span class="o">=</span> <span class="n">strat_ci_search</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">alternative</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;i:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> brute:</span><span class="si">{</span><span class="n">brute</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> fast:</span><span class="si">{</span><span class="n">fast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> fast_s:</span><span class="si">{</span><span class="n">fast_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">best_brute: </span><span class="si">{</span><span class="n">brute</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> best_fast:</span><span class="si">{</span><span class="n">fast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> best_fast_s: </span><span class="si">{</span><span class="n">fast_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">brute</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fast</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">brute</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fast_s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">brute</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fast</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">brute</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fast_s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_strat_test</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_strat_ci</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="comparison-with-wendell-schmee-1996-p-values-and-upper-confidence-bounds">
<h2>Comparison with Wendell &amp; Schmee (1996) <span class="math notranslate nohighlight">\(P\)</span>-values and upper confidence bounds<a class="headerlink" href="#comparison-with-wendell-schmee-1996-p-values-and-upper-confidence-bounds" title="Permalink to this headline">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_strat_test_ws</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">strata</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]</span>
    <span class="n">sams</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
    <span class="n">found</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">)):</span>
        <span class="n">compl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">60</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">j</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">alternative</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">p_ws</span> <span class="o">=</span> <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
            <span class="n">p_ws_c</span> <span class="o">=</span> <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">compl</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
            <span class="n">p_fast</span> <span class="o">=</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
            <span class="n">p_fast_c</span> <span class="o">=</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">compl</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ws: </span><span class="si">{</span><span class="n">p_ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> ws_c: </span><span class="si">{</span><span class="n">p_ws_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> best: </span><span class="si">{</span><span class="n">p_ws</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> best_c: </span><span class="si">{</span><span class="n">p_ws_c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;fast: </span><span class="si">{</span><span class="n">p_fast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> fast_c: </span><span class="si">{</span><span class="n">p_fast_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> best: </span><span class="si">{</span><span class="n">p_fast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> best_c: </span><span class="si">{</span><span class="n">p_fast_c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># time-consuming!</span>
<span class="n">test_strat_test_ws</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ws: 1 ws_c: 1.0000000000000002 best: [1, 2, 3, 4] best_c: [1, 1, 1, 1]
fast: 1 fast_c: 1 best: None best_c: [1, 1, 1, 1]
ws: 1 ws_c: 0.9999444444444434 best: [1, 2, 3, 4] best_c: [2, 1, 1, 1]
fast: 1 fast_c: 0.9999999988567956 best: None best_c: [1, 1, 1, 2]
ws: 1 ws_c: 0.999833333333334 best: [1, 2, 3, 4] best_c: [3, 1, 1, 1]
fast: 1 fast_c: 0.9999999789845687 best: None best_c: [1, 1, 2, 2]
ws: 1 ws_c: 0.9996666666666645 best: [1, 2, 3, 4] best_c: [4, 1, 1, 1]
fast: 1 fast_c: 0.9999998660332918 best: None best_c: [1, 2, 2, 2]
ws: 1 ws_c: 0.999444444444445 best: [1, 2, 3, 4] best_c: [5, 1, 1, 1]
fast: 1 fast_c: 0.9999992860845038 best: None best_c: [2, 2, 2, 2]
ws: 1 ws_c: 0.9991666666666645 best: [1, 2, 3, 4] best_c: [6, 1, 1, 1]
fast: 1 fast_c: 0.999997522402079 best: None best_c: [2, 2, 2, 3]
ws: 0.9999999999999987 ws_c: 0.9988333333333342 best: [1, 2, 3, 4] best_c: [7, 1, 1, 1]
fast: 1 fast_c: 0.9999931894258484 best: [1, 2, 3, 4] best_c: [2, 2, 3, 3]
ws: 0.9999999999810852 ws_c: 0.9984444444444441 best: [2, 2, 3, 4] best_c: [8, 1, 1, 1]
fast: 1.0 fast_c: 0.999982932037665 best: [1, 2, 3, 5] best_c: [2, 3, 3, 3]
ws: 0.9999999999432605 ws_c: 0.9980000000000002 best: [3, 2, 3, 4] best_c: [9, 1, 1, 1]
fast: 1.0 fast_c: 0.9999614134317659 best: [1, 2, 3, 6] best_c: [2, 3, 3, 4]
ws: 0.9999999998865183 ws_c: 0.9974999999999993 best: [4, 2, 3, 4] best_c: [10, 1, 1, 1]
fast: 1.0 fast_c: 0.9999200792544627 best: [1, 2, 3, 7] best_c: [2, 3, 4, 4]
ws: 0.9999999998108691 ws_c: 0.9921367521367547 best: [5, 2, 3, 4] best_c: [10, 1, 1, 2]
fast: 1.0 fast_c: 0.9998400267645521 best: [1, 2, 4, 7] best_c: [2, 3, 4, 5]
ws: 0.9999999997163019 ws_c: 0.9836369770580294 best: [6, 2, 3, 4] best_c: [10, 1, 1, 3]
fast: 1.0 fast_c: 0.9997087317388961 best: [1, 2, 4, 8] best_c: [2, 4, 4, 5]
ws: 0.9999999996028268 ws_c: 0.9718094612831454 best: [7, 2, 3, 4] best_c: [10, 1, 1, 4]
fast: 0.9999999999999999 fast_c: 0.9995066807966366 best: [1, 2, 4, 9] best_c: [3, 4, 4, 5]
ws: 0.9999999994704348 ws_c: 0.9565397887766312 best: [8, 2, 3, 4] best_c: [10, 1, 1, 5]
fast: 0.9999999999999992 fast_c: 0.9992064404749985 best: [1, 2, 5, 9] best_c: [3, 4, 5, 5]
ws: 0.9999999993191306 ws_c: 0.9377850725219145 best: [9, 2, 3, 4] best_c: [10, 1, 1, 6]
fast: 0.9999999999999958 fast_c: 0.9987578291088032 best: [1, 2, 5, 10] best_c: [3, 4, 5, 6]
ws: 0.9999999991489137 ws_c: 0.915568686095002 best: [10, 2, 3, 4] best_c: [10, 1, 1, 7]
fast: 0.9999999999999745 fast_c: 0.9980704752694506 best: [1, 2, 5, 11] best_c: [3, 4, 6, 6]
ws: 0.9809423942999241 ws_c: 0.005696151392875078 best: [10, 2, 8, 40] best_c: [7, 13, 18, 22]
fast: 0.9984282967061362 fast_c: 0.16107135673314985 best: [2, 10, 19, 29] best_c: [7, 12, 18, 23]
ws: 1 ws_c: 1 best: [0, 3, 2] best_c: [5, 2, 8]
fast: 1 fast_c: 1 best: None best_c: None
ws: 0.9999999999999991 ws_c: 1 best: [0, 3, 2] best_c: [5, 2, 8]
fast: 1 fast_c: 1 best: [0, 3, 2] best_c: None
ws: 0.9992124273532111 ws_c: 1 best: [0, 4, 2] best_c: [5, 2, 8]
fast: 0.9999999998166784 fast_c: 1 best: [0, 4, 2] best_c: None
ws: 0.9974471783173097 ws_c: 1 best: [0, 3, 4] best_c: [5, 2, 8]
fast: 0.9999999802958488 fast_c: 1 best: [0, 5, 2] best_c: None
ws: 0.9934753679865279 ws_c: 1 best: [0, 3, 5] best_c: [5, 2, 8]
fast: 0.9999995445513106 fast_c: 1 best: [0, 6, 2] best_c: None
ws: 0.9847170170007047 ws_c: 1 best: [0, 3, 6] best_c: [5, 2, 8]
fast: 0.9999950631446368 fast_c: 1 best: [0, 7, 2] best_c: None
ws: 0.9690334582586491 ws_c: 1 best: [0, 3, 7] best_c: [5, 2, 8]
fast: 0.9999663745711513 fast_c: 1 best: [0, 8, 2] best_c: None
ws: 0.9446636208286848 ws_c: 1 best: [0, 3, 8] best_c: [5, 2, 8]
fast: 0.9998332328548011 fast_c: 1 best: [0, 9, 2] best_c: None
ws: 0.9096534575901524 ws_c: 1 best: [0, 3, 9] best_c: [5, 2, 8]
fast: 0.9993435952582238 fast_c: 1 best: [0, 10, 2] best_c: None
ws: 0.8615152873035397 ws_c: 1 best: [0, 3, 10] best_c: [5, 2, 8]
fast: 0.9978334049132793 fast_c: 1 best: [0, 11, 2] best_c: None
ws: 0.7977494641581321 ws_c: 1 best: [0, 3, 11] best_c: [5, 2, 8]
fast: 0.9939841431087776 fast_c: 1 best: [0, 11, 3] best_c: None
ws: 0.7172269504435058 ws_c: 0.9999999999999961 best: [0, 3, 12] best_c: [5, 2, 8]
fast: 0.9872797224870071 fast_c: 1 best: [0, 12, 3] best_c: [5, 2, 8]
ws: 0.6217241051545268 ws_c: 0.9999999999999971 best: [0, 3, 13] best_c: [6, 2, 8]
fast: 0.9736250862338577 fast_c: 1.0 best: [0, 13, 3] best_c: [6, 2, 8]
ws: 0.5199586389671542 ws_c: 0.999999999999997 best: [2, 3, 12] best_c: [7, 2, 8]
fast: 0.946965994360294 fast_c: 1.0 best: [0, 14, 3] best_c: [7, 2, 8]
ws: 0.43870488123980333 ws_c: 0.9999999999999979 best: [7, 7, 4] best_c: [8, 2, 8]
fast: 0.9062534551334417 fast_c: 1.0 best: [0, 14, 4] best_c: [8, 2, 8]
ws: 0.37086615075619256 ws_c: 0.9999999999999977 best: [8, 7, 4] best_c: [9, 2, 8]
fast: 0.8457350377876189 fast_c: 1.0 best: [0, 15, 4] best_c: [9, 2, 8]
ws: 0 ws_c: 0 best: [0, 3, 2] best_c: [5, 2, 8]
fast: 0 fast_c: 0 best: None best_c: None
</pre></div>
</div>
</div>
</div>
<section id="reproduce-tables-from-wendell-schmee">
<h3>Reproduce tables from Wendell &amp; Schmee<a class="headerlink" href="#reproduce-tables-from-wendell-schmee" title="Permalink to this headline">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Wendell &amp; Schmee lead example, p. 827</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">good</span> <span class="o">=</span> <span class="mi">10</span> 
<span class="n">p</span> <span class="o">=</span> <span class="mf">.067081</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>\
      <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.067081 (0.23485578913926813, [2, 8]) (0.06708103400254271, [2, 8])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 2, row 1</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span> 
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">good</span> <span class="o">=</span> <span class="mi">15</span> 
<span class="n">p</span> <span class="o">=</span> <span class="mf">.01194</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span> \
      <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.01194 (0.06481873546070493, [10, 5]) (0.011942274979969247, [10, 5])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 2, row 2</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span> 
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">good</span> <span class="o">=</span> <span class="mi">15</span> 
<span class="n">p</span> <span class="o">=</span> <span class="mf">.07232</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span> \
      <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.07232 (0.26226855041248087, [15, 0]) (0.07231577125487271, [15, 0])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 2, row 3</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">good</span> <span class="o">=</span> <span class="mi">150</span> 
<span class="n">p</span> <span class="o">=</span> <span class="mf">.09958</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span> \
      <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.09958 (0.3292825209349363, [150, 0]) (0.09957652360481824, [150, 0])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 2, row 9. </span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">good</span> <span class="o">=</span> <span class="mi">30</span> 
<span class="n">p</span> <span class="o">=</span> <span class="mf">.03775</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>\
      <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.03775 (0.349110173834897, [25, 5, 0]) (0.037749475267350535, [24, 6, 0])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 2, row 10. </span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">good</span> <span class="o">=</span> <span class="mi">300</span> 
<span class="n">p</span> <span class="o">=</span> <span class="mf">.04902</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">strat_test</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>\
      <span class="n">strat_test_ws</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.04902 (0.4006985692204492, [247, 53, 0]) (0.04902098371080246, [228, 72, 0])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># compare with Wendell &amp; Schmee&#39;s R code.</span>
<span class="c1"># </span>
<span class="c1"># &gt; pmax.function(c(500,300,200),c(75,50,25),c(2,1,0),50)</span>
<span class="c1">#            [,1] [,2] [,3] [,4]</span>
<span class="c1"># [1,] 0.02767569   28   21    1</span>
<span class="c1">#</span>
<span class="c1"># indicating a maximum p-value of 0.02768 occurring under the null of 50 errors</span>
<span class="c1"># with those errors distributed as (28,21,1).</span>
<span class="nb">print</span><span class="p">(</span><span class="n">strat_test</span><span class="p">([</span><span class="mi">500</span><span class="p">,</span><span class="mi">300</span><span class="p">,</span><span class="mi">200</span><span class="p">],[</span><span class="mi">75</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">50</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;upper&#39;</span><span class="p">),</span>\
      <span class="n">strat_test_ws</span><span class="p">([</span><span class="mi">500</span><span class="p">,</span><span class="mi">300</span><span class="p">,</span><span class="mi">200</span><span class="p">],[</span><span class="mi">75</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">50</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;upper&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.25567352840348917, [38, 12, 0]) (0.02767568706972813, [28, 21, 1])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 3, Row 1</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">ub</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ub</span><span class="p">,</span>
      <span class="n">strat_ci_bisect</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">,</span> <span class="n">p_value</span><span class="o">=</span><span class="n">strat_test_ws</span><span class="p">),</span>
      <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>
      <span class="n">strat_ci_wright</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>10 (10, [6, 4]) (16, [11, 5]) 23
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 3, Row 7.</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> 
<span class="n">ub</span> <span class="o">=</span> <span class="mi">599</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ub</span><span class="p">,</span>
      <span class="n">strat_ci_bisect</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">,</span> <span class="n">p_value</span><span class="o">=</span><span class="n">strat_test_ws</span><span class="p">),</span>
      <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>
      <span class="n">strat_ci_wright</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>599 (599, [2, 597]) (701, [124, 577]) 876
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 3, Row 10. WARNING: LONG RUN TIME</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]</span> 
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">ub</span> <span class="o">=</span> <span class="mi">298</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ub</span><span class="p">,</span>
      <span class="n">strat_ci_bisect</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">,</span> <span class="n">p_value</span><span class="o">=</span><span class="n">strat_test_ws</span><span class="p">),</span>
      <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>
      <span class="n">strat_ci_wright</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>298 (298, [226, 72, 0]) (499, [423, 76, 0]) 643
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Table 3, last row. LONG RUN TIME</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">75</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> 
<span class="n">ub</span> <span class="o">=</span> <span class="mi">471</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ub</span><span class="p">,</span> <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>
     <span class="n">strat_ci_bisect</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">,</span> <span class="n">p_value</span><span class="o">=</span><span class="n">strat_test_ws</span><span class="p">),</span>
     <span class="n">strat_ci_wright</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>471 (716, [503, 162, 51]) (471, [258, 213, 0]) 1133
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="when-is-the-new-method-sharper-than-wendell-schmee">
<h2>When is the new method sharper than Wendell &amp; Schmee?<a class="headerlink" href="#when-is-the-new-method-sharper-than-wendell-schmee" title="Permalink to this headline">#</a></h2>
<p>In general, when there is large heterogeneity of rates across strata.</p>
<p>strata = [100, 100]
sams = [30,30]
found = [15,0]
(68, [34, 34]) (68, [67, 1]) 74</p>
<p>strata = [100, 100]
sams = [30,30]
found = [20,0]
(85, [43, 42]) (83, [79, 4]) 89</p>
<p>strata = [100, 100, 100]
sams = [25, 25, 25]
found = [20, 0, 0]
(105, [35, 35, 35]) (102, [88, 7, 7]) 118</p>
<p>strata = [100, 100, 100, 100]
sams = [25, 25, 25, 25]
found = [10, 0, 0, 0]</p>
<p>strata = [100, 100, 100, 100]
sams = [25,25,25,25]
found = [20,0,0,0]
Ran for a week without completing. Fast method took under a second.
—- (107, [88, 6, 6, 7]) 131</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> 
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span>
<span class="c1">#      strat_ci_bisect(strata, sams, found, alternative=alternative, p_value=strat_test_ws), # takes forever</span>
      <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>
      <span class="n">strat_ci_wright</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(107, [88, 6, 6, 7]) 131
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">strat_ci_bisect</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">,</span> <span class="n">p_value</span><span class="o">=</span><span class="n">strat_test_ws</span><span class="p">),</span>
      <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>
      <span class="n">strat_ci_wright</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(61, [20, 21, 20]) (67, [60, 3, 4]) 86
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">*</span><span class="mi">100</span>
<span class="n">sams</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">55</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span>
<span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">100</span>

<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="nb">print</span><span class="p">(</span>\
      <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">),</span>\
      <span class="n">strat_ci_wright</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1384, [76, 70, 64, 58, 53, 47, 42, 37, 32, 28, 24, 20, 17, 14, 12, 10, 9, 8, 7, 6, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 76, 70, 64, 58, 53, 47, 42, 37, 32, 28, 24, 20, 17, 14, 12, 10, 9, 8, 7, 6, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 3198
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># test empirical coverage</span>
<span class="n">reps</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">cl</span> <span class="o">=</span> <span class="mf">0.95</span>
<span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
<span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">]</span>
<span class="n">sams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">75</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
<span class="n">good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">500</span><span class="p">]</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good</span><span class="p">)</span>
<span class="n">cover</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">verb</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">hypergeom</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">sams</span><span class="p">)</span>
    <span class="n">ub</span> <span class="o">=</span> <span class="n">strat_ci</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="n">sams</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">,</span> <span class="n">cl</span><span class="o">=</span><span class="n">cl</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verb</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f: </span><span class="si">{}</span><span class="s2"> ub: </span><span class="si">{}</span><span class="s2"> best: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">ub</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ub</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">cover</span> <span class="o">=</span> <span class="n">cover</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">ub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">g</span> <span class="k">else</span> <span class="n">cover</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cover</span><span class="p">,</span> <span class="n">cover</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">cover</span><span class="o">/</span><span class="n">reps</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2 2 1.0
102 102 1.0
202 202 1.0
302 302 1.0
402 401 0.9975124378109452
502 501 0.99800796812749
602 601 0.9983388704318937
702 701 0.9985754985754985
802 801 0.9987531172069826
902 901 0.9988913525498891
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.999
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Philip B. Stark<br/>
  
      &copy; Copyright 2023.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>